import os
import cv2
import pandas as pd
import json
from PIL import Image
import matplotlib.pyplot as plt
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.applications.resnet50 import preprocess_input
from tensorflow.keras.layers import GlobalAveragePooling2D
from tensorflow.keras.models import Model

def recommend(detected_object_class, photo_name):
    # Define directories and file paths
    IMAGE_DIR = os.path.join('.', 'static/images')
    STATIC_DIR = os.path.join('.', 'static')
    csv_file_path = os.path.join(STATIC_DIR, 'dataset_for_cosine_relation.csv')
    yolo_out_path = os.path.join(IMAGE_DIR,'yolo_out')

    # Specify the input image path here
    input_image_path = os.path.join(yolo_out_path,photo_name)

    # Path to the JSON file generated by detect_objects.py
    json_input_path = os.path.join('.','static/detected_obj.json')

    # # ResNet50 model for feature extraction
    # feat_extractor = ResNet50(weights='imagenet', include_top=False, input_shape=(224, 224, 3), pooling='avg')
    
    # Load ResNet50 model without the top layers
    base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

    # Replace GlobalMaxPooling2D with GlobalAveragePooling2D
    x = base_model.output
    x = GlobalAveragePooling2D()(x)
    feat_extractor = Model(inputs=base_model.input, outputs=x)

    # Preprocess function for ResNet50
    def preprocess_for_resnet50(image):
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  # Convert BGR to RGB
        image = cv2.resize(image, (224, 224))  # Resize to match ResNet50 input size
        image = preprocess_input(image)  # Preprocess input for ResNet50
        return image

    # Function to extract features using ResNet50
    def extract_features(image):
        img_processed = preprocess_for_resnet50(image)
        img_processed = np.expand_dims(img_processed, axis=0)  # Add batch dimension
        features = feat_extractor.predict(img_processed)
        return features.flatten()

    # Load the CSV file
    product_data = pd.read_csv(csv_file_path)
    product_data['image_name'] = product_data['image_name'].fillna('')

    # Base directory for product images
    image_database_dir = os.path.join('.', 'static/product_images/cropped_rec')  # Adjust this path as needed
    image_database_dir = os.path.join(image_database_dir, detected_object_class)

    # Load and process the specified input image
    input_image = Image.open(input_image_path)
    input_image_features = extract_features(np.array(input_image))

    # Load the detection results from JSON file
    with open(json_input_path, 'r') as json_file:
        detections_dict = json.load(json_file)

    # Extract features only for products matching the detected object class
    def extract_class_specific_features(product_data, detected_object_class):
        detected_object_class_upper = detected_object_class.upper()
        matching_products = product_data[product_data['product_name'].str.strip().str.upper() == detected_object_class_upper]

        class_specific_features = []
        for img_name in matching_products['image_name']:
            try:
                img_name = img_name.strip()
                if img_name:
                    img_path = os.path.join('.','static/product_images/cropped_rec',detected_object_class,img_name)
                    img = Image.open(img_path)
                    features = extract_features(np.array(img))
                    class_specific_features.append(features)
            except Exception as e:
                print(f"Error processing {img_path}: {e}")

        return matching_products, np.array(class_specific_features)

    # Get class-specific features
    filtered_product_data, filtered_product_features = extract_class_specific_features(product_data, detected_object_class)

    # Function to recommend products based on the input image and detected object class
    def recommend_products(input_image_features, product_features, product_data, top_k=10):
        if product_features.size == 0:
            print("No products found for the detected class.")
            return []

        similarity_scores = cosine_similarity([input_image_features], product_features)[0]
        top_indices = similarity_scores.argsort()[-top_k:][::-1]
        top_scores = similarity_scores[top_indices]

        recommendations = []
        for idx, score in zip(top_indices, top_scores):
            product_info = product_data.iloc[idx]
            recommendations.append({
                "product_id": product_info['product_id'],
                "product_name": product_info['product_name'],
                "image_name": product_info['image_name'],
                "similarity_score": float(score)  # Convert numpy.float32 to native Python float
            })
        return recommendations

    # Get recommendations
    recommendations = recommend_products(input_image_features, filtered_product_features, filtered_product_data, top_k=10)

    # Save the recommendations to a JSON file
    json_output_path = os.path.join(STATIC_DIR, 'recommended_obj.json')
    with open(json_output_path, 'w') as json_file:
        json.dump(recommendations, json_file, indent=4)

    print(f"Recommendations saved to {json_output_path}")

    def display_recommendations(recommendations):
        fig, axes = plt.subplots(1, len(recommendations), figsize=(20, 5))
        if len(recommendations) == 1:
            axes = [axes]

        for i, rec in enumerate(recommendations):
            print(f"Product ID: {rec['product_id']}, Product Name: {rec['product_name']}, Similarity Score: {rec['similarity_score']:.2f}")
            img_path = os.path.join(image_database_dir, product_data.loc[product_data['product_id'] == rec['product_id'], 'image_name'].values[0])
            img = cv2.imread(img_path)
            if img is not None:
                img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
                axes[i].imshow(img_rgb)
                axes[i].set_title(f"ID: {rec['product_id']}\nName: {rec['product_name']}\nScore: {rec['similarity_score']:.2f}")
                axes[i].axis('off')
        plt.show()

#     display_recommendations(recommendations)
    
# recommend("DRESS", "DRESScrop1.jpg")
